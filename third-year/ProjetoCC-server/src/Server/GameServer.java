/*  * Copyright (C) 2015 José Sousa & Nuno Carvalho * * This program is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with this program.  If not, see <http://www.gnu.org/licenses/>. */package Server;import Game.DataInvalidaException;import Game.Desafio;import Game.Perguntas;import Game.ParsingException;import Game.Pergunta;import Game.User;import Game.Security;import Net.CCPacket;import Net.CCSocket;import Net.ExcessBytesException;import Net.PacketTooSmallException;import Server.GameNetwork.ServerPool;import java.io.IOException;import java.io.PrintWriter;import java.math.BigInteger;import java.net.SocketAddress;import java.net.SocketException;import java.net.SocketTimeoutException;import java.time.format.DateTimeFormatter;import java.time.format.DateTimeParseException;import java.util.HashMap;import java.util.HashSet;import java.util.Map;import java.util.Map.Entry;import java.util.Set;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.ScheduledFuture;import java.util.concurrent.TimeUnit;/** * * @author José Francisco & Nuno Carvalho */public class GameServer implements Runnable {    //escrever logs para este printwriter    private final PrintWriter logger;    //utilizadores registados! global-wide    private final Map<String, User> users;    //utilizadores logados e respetivos endereços!     private final Map<SocketAddress, String> connections;    //desafios neste servidor - local     private final Map<String, Desafio> desafios;    //set com os nomes dos utilizadores que ja estao em desafios - local    private final Set<String> jogadores;    //map que associa um utilizador ao seu desafio ativo - local    private final Map<String, Desafio> desafiosATIVOS;    //excutor que executa os checks aos desafios apos 15 mins    private final ScheduledExecutorService executor;    //map que associa o nome dum desafio ao seu "cleanup"    private final Map<String, ScheduledFuture> limpezasDesafio;    //mensagem genérica OK    private final static byte OK[] = {0};    //socket deste servidor    private final CCSocket socket;    //perguntas disponiveis    private final Perguntas perguntas;    //servidores para difundir informação    private final ServerPool servers;    public GameServer(EasyLogger logger, ServerPool servers, ConcurrentHashMap<String, User> users) throws SocketException, ParsingException, IOException {        this.logger = logger;        this.users = users;        this.connections = new HashMap<>();        this.desafios = new ConcurrentHashMap<>();        this.socket = new CCSocket(1234);        this.perguntas = new Perguntas("desafio-000001.txt");        this.jogadores = new HashSet<>();        this.desafiosATIVOS = new HashMap<>();        this.executor = Executors.newScheduledThreadPool(2);        this.limpezasDesafio = new HashMap<>();        this.servers = servers;    }    public Map<String, User> getUsers() {        return this.users;    }    public static void sendError(CCSocket sender, String errorMsg, short label, SocketAddress addr) throws ExcessBytesException, IOException {        byte[] error = errorMsg.getBytes();        CCPacket response = new CCPacket((byte) 0, (byte) 0, (short) label, (byte) 0);        response.addCampo((byte) 255, error);        sender.send(response, addr);    }    private void sendError(String errorMsg, short label, SocketAddress addr) throws ExcessBytesException, IOException {        byte[] error = errorMsg.getBytes();        CCPacket response = new CCPacket((byte) 0, (byte) 0, (short) label, (byte) 0);        response.addCampo((byte) 255, error);        this.socket.send(response, addr);    }    private void registerAux(CCPacket ccp) throws IOException, ExcessBytesException {        String nome, nick, password;        try {            nome = new String(ccp.getCampo(1));            nick = new String(ccp.getCampo(2));            password = new String(ccp.getCampo(3));            if (this.users.containsKey(nick)) {                sendError("Nick em uso!!!", ccp.getLabel(), ccp.getSender());            } else {                if (ccp.getSeguranca() != 0) {                    password = Security.decrypt(password);                }                User user = new User(nome, nick, password);                this.users.put(nick, user);                this.servers.broadcastNewUser(user, 0);                this.logger.println("Registado! Nome:" + nome + " Alcunha:" + nick + " Password:" + password);                CCPacket reply = new CCPacket((byte) 0, (byte) 0, (short) ccp.getLabel(), 0);                reply.addCampo(0, OK);                this.socket.send(reply, ccp.getSender());            }        } catch (NullPointerException ex) {            sendError("Campos em falta!!!", ccp.getLabel(), ccp.getSender());        } catch (Exception ex) {            sendError("DECRYPTION EXCEPTION!", ccp.getLabel(), ccp.getSender());            this.logger.println("Decryption Exception!");        }    }    private void loginAux(CCPacket ccp) throws IOException, ExcessBytesException {        String nick, password;        try {            nick = new String(ccp.getCampo(2));            password = new String(ccp.getCampo(3));            if (ccp.getSeguranca() != 0) {                password = Security.decrypt(password);            }            User user = this.users.get(nick);            if (user == null) {                sendError("User inexistente!!!", ccp.getLabel(), ccp.getSender());            } else if (!user.getPassword().equals(password) || user.getPassword().equals("")) {                sendError("Password errada!!!", ccp.getLabel(), ccp.getSender());            } else if (this.connections.containsKey(ccp.getSender())) {                sendError("Este user já está logado!!!", ccp.getLabel(), ccp.getSender());            } else {                this.connections.put(ccp.getSender(), user.getNick());                CCPacket reply = new CCPacket(0, 0, ccp.getLabel(), 0);                reply.addCampo(0, OK);                reply.addCampo(1, user.getName().getBytes());                reply.addCampo(20, BigInteger.valueOf((short) user.getScoreGlobal()).toByteArray());                this.socket.send(reply, ccp.getSender());            }        } catch (NullPointerException ex) {            sendError("Campos em falta!!!", ccp.getLabel(), ccp.getSender());        } catch (Exception ex) {            sendError("DECRYPTION EXCEPTION!", ccp.getLabel(), ccp.getSender());            this.logger.println("Decryption Exception!");        }    }    private void logoutAux(CCPacket ccp) throws ExcessBytesException, IOException {        //ver se ja existe user ativo!        String nick = this.connections.get(ccp.getSender());        if (nick == null) {            sendError("Você não está logado!!!", ccp.getLabel(), ccp.getSender());        } else {            this.connections.remove(ccp.getSender());            CCPacket reply = new CCPacket(0, 0, ccp.getLabel(), 0);            reply.addCampo(0, OK);            this.socket.send(ccp, ccp.getSender());        }    }    private void makeChallengeAux(CCPacket ccp) throws ExcessBytesException, IOException {        try {            String nome, data, hora, criador;            criador = this.connections.get(ccp.getSender());            if (criador == null) {                sendError("Não está logado!!! Faça login"                        + " e tente de novo!!!", ccp.getLabel(), ccp.getSender());                return;            }            nome = new String(ccp.getCampo(7));            if (this.desafios.containsKey(nome)) {                sendError("Já existe desafio com este nome!!!", ccp.getLabel(), ccp.getSender());            } else if (this.desafiosATIVOS.containsKey(criador)) {                sendError("Já possui um desafio ativo!!!", ccp.getLabel(), ccp.getSender());            } else {                Desafio d;                if (ccp.getCampo(4) == null && ccp.getCampo(5) == null) {                    d = new Desafio(nome, criador, this.perguntas);                } else {                    data = new String(ccp.getCampo(4));                    hora = new String(ccp.getCampo(5));                    d = new Desafio(nome, criador, this.perguntas, data.concat(hora));                }                this.desafios.put(nome, d);                this.desafiosATIVOS.put(criador, d);                this.logger.format("Desafio %s marcado para as %s por %s\n",                        nome,                        d.getLDTime().format(DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm:ss")),                        criador);                //marcar a limpeza do desafio para daqui a 10 mins                Runnable r;                r = () -> {                    try {                        this.logger.format("Time is UP! Desafio %s a ser finalizado..\n", d.getNome());                        d.finalizarDesafio();                        if (d.getJogadores() < 2) {                            this.logger.println("Este desafio não tem utilizadores"                                    + "suficientes! MIN:2");                        } else {                            this.logger.format("Highscore do desafio %s foi %d\n", d.getNome(), d.getHighScore());                            String campeao = d.calculaCampeao();                            this.logger.format("User %s amealhou mais 3 pontos!\n", campeao);                            for (Entry<String, Integer> e : d.getPontuacoes()) {                                User u = this.users.get(e.getKey());                                u.addScoreGlobal(e.getValue());                                this.servers.broadcastNewUser(u, e.getValue());                            }                        }                        //remover desafio                        this.desafios.remove(d.getNome());                        //remover desafios ativos                        while (this.desafiosATIVOS.values().remove(d));                        this.logger.println("ScheduledTask completed!");                    } catch (Exception e) {                        this.logger.println(e.getMessage());                    }                };                this.limpezasDesafio.put(nome, this.executor.schedule(r,                        (long) d.getMinutosToInicio() + 10,                        TimeUnit.MINUTES));                ccp.setTipo(0);                ccp.addCampo(0, OK);                this.socket.send(ccp, ccp.getSender());            }        } catch (NullPointerException e) {            sendError("Campos em falta!!!", ccp.getLabel(), ccp.getSender());        } catch (DateTimeParseException e) {            sendError("Data e/ou hora com formato inválido!!!", ccp.getLabel(), ccp.getSender());        } catch (DataInvalidaException ex) {            sendError("Impossível, não pode marcar desafios para o passado!!!", ccp.getLabel(), ccp.getSender());        }    }    private void listChallengesAux(CCPacket ccp) throws ExcessBytesException, IOException {        if (!this.connections.containsKey(ccp.getSender())) {            sendError("Não está logado!!! Faça login"                    + " e tente de novo!!!", ccp.getLabel(), ccp.getSender());            return;        }        CCPacket r = new CCPacket(0, 0, ccp.getLabel(), 0);        for (Desafio d : this.desafios.values()) {            r.addCampo(7, d.getNome().getBytes());            r.addCampo(4, d.getData().getBytes());            r.addCampo(5, d.getHora().getBytes());        }        this.socket.send(r, ccp.getSender());    }    private void acceptChallengeAux(CCPacket ccp) throws ExcessBytesException, IOException {        try {            String jogador = this.connections.get(ccp.getSender());            if (jogador == null) {                sendError("Não está logado!!! Faça login"                        + " e tente de novo!!!", ccp.getLabel(), ccp.getSender());                return;            }            String desafio = new String(ccp.getCampo(7));            Desafio d = this.desafios.get(desafio);            if (d == null) {                sendError("Não existe tal desafio!!!", ccp.getLabel(), ccp.getSender());            } else if (this.desafiosATIVOS.containsKey(jogador)) {                sendError("Só pode ter um desafio ativo!!!", ccp.getLabel(), ccp.getSender());            } else {                if (d.addJogador(jogador)) {                    this.desafiosATIVOS.put(jogador, d);                    CCPacket r = new CCPacket(0, 0, ccp.getLabel(), 0);                    r.addCampo(0, OK);                    this.socket.send(r, ccp.getSender());                } else {                    sendError("Já acabou este desafio!!!", ccp.getLabel(), ccp.getSender());                }            }        } catch (NullPointerException e) {            sendError("Campos em falta!!!", ccp.getLabel(), ccp.getSender());        }    }    private void deleteChallengeAux(CCPacket ccp) throws ExcessBytesException, IOException, PacketTooSmallException {        try {            String jogador = this.connections.get(ccp.getSender());            if (jogador == null) {                sendError("Não está logado!!! Faça login"                        + " e tente de novo!!!", ccp.getLabel(), ccp.getSender());                return;            }            String desafio = new String(ccp.getCampo(7));            Desafio d = this.desafios.remove(desafio);            if (d == null) {                sendError("Não existe tal desafio!!!", ccp.getLabel(), ccp.getSender());            } else if (d.podeJogar()) {                sendError("O desafio já começou, não pode remover agora!!!", ccp.getLabel(), ccp.getSender());            } else {                while (this.desafiosATIVOS.values().remove(d));                //obter o future que irá limpar o desafio, e cancelar.                //de notar, que se o desafio estiver a ser finalizado                //nada será feito                this.limpezasDesafio.get(desafio).cancel(false);                CCPacket r = new CCPacket(0, 0, ccp.getLabel(), 0);                r.addCampo(0, OK);                this.socket.send(r, ccp.getSender());            }        } catch (NullPointerException e) {            sendError("Campos em falta!!!", ccp.getLabel(), ccp.getSender());        }    }    private void quitAux(CCPacket ccp) throws ExcessBytesException, IOException, PacketTooSmallException {        try {            String jogador = this.connections.get(ccp.getSender());            if (jogador == null) {                sendError("Não está logado!!! Faça login"                        + " e tente de novo!!!", ccp.getLabel(), ccp.getSender());                return;            }            Desafio d = this.desafiosATIVOS.remove(jogador);            System.out.println(d);            if (d == null) {                sendError("Não tem desafios ativos!!!", ccp.getLabel(), ccp.getSender());            } else {                //remover pontuaçoes do jogador neste desafio                d.removerJogador(jogador);                CCPacket r = new CCPacket(0, 0, ccp.getLabel(), 0);                r.addCampo(0, OK);                this.socket.send(r, ccp.getSender());            }        } catch (NullPointerException e) {            sendError("Campos em falta!!!", ccp.getLabel(), ccp.getSender());        }    }    private void endAux(CCPacket ccp) throws ExcessBytesException, IOException, PacketTooSmallException {        try {            String jogador = this.connections.get(ccp.getSender());            if (jogador == null) {                sendError("Não está logado!!! Faça login"                        + " e tente de novo!!!", ccp.getLabel(), ccp.getSender());                return;            }            Desafio d = this.desafiosATIVOS.remove(jogador);            System.out.println(d);            if (d == null) {                sendError("Não tem desafios ativos!!!", ccp.getLabel(), ccp.getSender());            } else {                //remover pontuaçoes do jogador neste desafio                d.removerJogador(jogador);                this.connections.remove(ccp.getSender());                CCPacket r = new CCPacket(0, 0, ccp.getLabel(), 0);                r.addCampo(0, OK);                this.socket.send(r, ccp.getSender());            }        } catch (NullPointerException e) {            sendError("Campos em falta!!!", ccp.getLabel(), ccp.getSender());        }    }    private void jogarAux(CCPacket ccp) throws ExcessBytesException, IOException, PacketTooSmallException {        try {            if (!this.connections.containsKey(ccp.getSender())) {                sendError("Não está logado!!! Faça login"                        + "e tente de novo!!!", ccp.getLabel(), ccp.getSender());                return;            }            String jogador = this.connections.get(ccp.getSender());            Desafio d = this.desafiosATIVOS.get(jogador);            if (d == null) {                sendError("Não aceitou desafios ainda!!!", ccp.getLabel(), ccp.getSender());            } // se ainda nao estamos na data            else if (!d.podeJogar()) {                sendError("Ainda não começou este desafio!!!", ccp.getLabel(), ccp.getSender());            } // não estar neste desafio            else if (d.nrJogadores() == 1) {                sendError("Mais nenhum jogador aceitou o seu desafio!!! "                        + "Precisa de dois ou mais jogadores", ccp.getLabel(), ccp.getSender());            } else {                int questao = d.getNumPergunta(jogador);                //exemplo de resposta à primeira pergunta                Pergunta p = d.getPergunta(questao);                CCPacket r = new CCPacket(0, 0, ccp.getLabel(), ccp.getTipo());                r.addCampo(7, d.getNome().getBytes());                r.addCampo(10, BigInteger.valueOf(questao).toByteArray());                r.addCampo(11, p.getPergunta().getBytes());                r.addCampo(12, BigInteger.valueOf(p.getCerta()).toByteArray());                r.addCampo(13, p.getResposta1().getBytes());                r.addCampo(13, p.getResposta2().getBytes());                r.addCampo(13, p.getResposta3().getBytes());                //r.addCampo(16, p.getImg());                this.socket.send(r, ccp.getSender());                d.incNumPergunta(jogador);                if (questao == 10) {                    this.logger.format("Utilizador %s irá responder"                            + " à última pergunta!\n", jogador);                } else {                    this.logger.format("Utilizador %s irá responder"                            + " à pergunta %d!\n", jogador, questao);                }                boolean good = false;                try {                    while (!good) {                        //no caso de receber outra comunicação, dar ordem                        //para esperar                        this.socket.setTimeout(300);                        CCPacket reply = socket.receive();                        if (reply.getLabel() != ccp.getLabel()) {                            reply.addCampo(255, ("Tente mais tarde, Servidor ocupado "                                    + "com uma transferência!").getBytes());                        } else {                            //ordem para iniciar transferencia                            this.socket.setTimeout(0);                            good = true;                            FileTransfer.sendFile(socket, ccp.getSender(), ccp.getLabel(), p.getImg());                            FileTransfer.sendFile(socket, ccp.getSender(), ccp.getLabel(), p.getMusic());                        }                    }                } catch (SocketTimeoutException e) {                    this.logger.println("Cliente unreachable!");                }            }        } catch (NullPointerException e) {            sendError("Campos em falta!!!", ccp.getLabel(), ccp.getSender());        }    }    private void answerAux(CCPacket ccp) throws ExcessBytesException, IOException {        String jogador = this.connections.get(ccp.getSender());        if (jogador == null) {            sendError("Não está logado!!! Faça login"                    + "e tente de novo!!!", ccp.getLabel(), ccp.getSender());            return;        }        try {            Integer escolha = new BigInteger(ccp.getCampo(6)).intValue();            Integer questao = new BigInteger(ccp.getCampo(10)).intValue();            Desafio d = this.desafiosATIVOS.get(jogador);            if (d == null) {                sendError("Não aceitou desafios ainda!!!", ccp.getLabel(), ccp.getSender());            }//resposta 0 indica TIME UP do cliente             else if (questao < 0 && questao > 9) {                sendError("Qestão inválida! Apenas de 0 a 9 (inclusive)!!", ccp.getLabel(), ccp.getSender());            } else {                Pergunta p = d.getPergunta(questao);                if (p.getCerta() == escolha) {                    //acertou                                        d.addPontuacao(jogador, 1);                    this.logger.format("%s recebeu %d pontos\n", jogador, 1);                } else if (p.getCerta() == 0) {                    this.logger.format("%s recebeu %d pontos\n", jogador, 1);                } else {                    //errou                    d.addPontuacao(jogador, -1);                    this.logger.format("%s recebeu %d pontos\n", jogador, -1);                }                //se respondeu à última pergunta, remover do desafio ativo                if (d.getNumPergunta(jogador) == 10) {                    this.desafiosATIVOS.remove(jogador);                    d.finalizaJogador(jogador);                }                CCPacket r = new CCPacket(0, 0, ccp.getLabel(), 0);                r.addCampo(0, OK);                this.socket.send(r, ccp.getSender());            }        } catch (NullPointerException e) {            sendError("Campos em falta!!!", ccp.getLabel(), ccp.getSender());        }    }    private void listRankingAux(CCPacket ccp) throws ExcessBytesException, IOException {        String jogador = this.connections.get(ccp.getSender());        if (jogador == null) {            sendError("Não está logado!!! Faça login"                    + "e tente de novo!!!", ccp.getLabel(), ccp.getSender());            return;        }        CCPacket ret = new CCPacket(0, 0, ccp.getLabel(), 0);        for (User user : users.values()) {            ret.addCampo(1, user.getName().getBytes());            ret.addCampo(2, user.getNick().getBytes());            ret.addCampo(20, BigInteger.valueOf(user.getScoreGlobal()).toByteArray());        }        this.socket.send(ret, ccp.getSender());    }    public void processPacket(CCPacket ccp) throws IOException, ExcessBytesException, PacketTooSmallException {        switch (ccp.getTipo()) {            case 1:                this.logger.format("Hello <- %s\n", ccp.getSender().toString());                this.socket.send(new CCPacket((byte) 0, (byte) 0, (short) ccp.getLabel(), (byte) 2), ccp.getSender());                break;            case 2:                this.logger.format("Register <- %s\n", ccp.getSender().toString());                registerAux(ccp);                break;            case 3:                this.logger.format("Login <- %s\n", ccp.getSender().toString());                loginAux(ccp);                break;            case 4:                this.logger.format("Logout <- %s\n", ccp.getSender().toString());                logoutAux(ccp);                break;            case 5:                this.logger.format("Quit <- %s\n", ccp.getSender().toString());                quitAux(ccp);                break;            case 6:                this.logger.format("Quit <- %s\n", ccp.getSender().toString());                endAux(ccp);                break;            case 7:                this.logger.format("List Desafios <- %s\n", ccp.getSender().toString());                listChallengesAux(ccp);                break;            case 8:                this.logger.format("Make Desafios <- %s\n", ccp.getSender().toString());                makeChallengeAux(ccp);                break;            case 9:                this.logger.format("Aceitar Desafio <- %s\n", ccp.getSender().toString());                acceptChallengeAux(ccp);                break;            case 10:                this.logger.format("Remover Desafio <- %s\n", ccp.getSender().toString());                deleteChallengeAux(ccp);                break;            case 11:                this.logger.format("Resposta <- %s\n", ccp.getSender().toString());                answerAux(ccp);                break;            case 13:                this.logger.format("List Ranking <- %s\n", ccp.getSender().toString());                listRankingAux(ccp);                break;            //JOGAR            case 20:                this.logger.format("Jogar <- %s\n", ccp.getSender().toString());                jogarAux(ccp);                break;        }    }    @Override    public void run() {        byte buf[] = new byte[4800];        try {            this.logger.println("Server aberto");            while (true) {                processPacket(this.socket.receive());            }        } catch (IOException ex) {            this.logger.println(ex.getMessage());        } catch (PacketTooSmallException ex) {            this.logger.println(ex.getMessage());        } catch (ExcessBytesException ex) {            this.logger.println("Pacote excedeu limite de bytes" + ex.getMessage());        }    }}